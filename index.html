<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LASP - LoRa Audio Streaming Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0f172a;
            background-image: 
                linear-gradient(to bottom, #0f172a 0%, #1e293b 100%),
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
            background-blend-mode: normal, screen, screen;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px 20px;
            color: #e2e8f0;
        }

        .container {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            padding: 48px;
            box-shadow: 
                0 0 0 1px rgba(255, 255, 255, 0.05),
                0 20px 60px rgba(0, 0, 0, 0.6);
            max-width: 1400px;
            width: 100%;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            padding-bottom: 32px;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 8px;
            letter-spacing: -0.025em;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 0.875rem;
            font-weight: 400;
        }

        .status-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
            padding: 24px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.08);
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .status-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            font-weight: 600;
        }

        .status-value {
            font-size: 1rem;
            font-weight: 600;
            color: #cbd5e0;
            transition: color 0.3s;
        }

        .status-value.connected {
            color: #10b981;
        }

        .status-value.streaming {
            color: #3b82f6;
        }

        .status-value.inactive {
            color: #64748b;
        }

        .section {
            margin-bottom: 32px;
        }

        .section-header {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #94a3b8;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .connection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        button {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-family: inherit;
            letter-spacing: 0.01em;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 14px rgba(239, 68, 68, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.3);
        }

        .btn-secondary {
            background: rgba(71, 85, 105, 0.4);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(71, 85, 105, 0.6);
        }

        .source-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }

        .source-card {
            background: rgba(15, 23, 42, 0.6);
            border: 2px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            padding: 28px 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .source-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .source-card:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(59, 130, 246, 0.3);
            transform: translateY(-2px);
        }

        .source-card:hover::before {
            opacity: 0.6;
        }

        .source-card.active {
            background: rgba(59, 130, 246, 0.12);
            border-color: #3b82f6;
        }

        .source-card.active::before {
            opacity: 1;
        }

        .source-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #f1f5f9;
        }

        .source-desc {
            font-size: 0.875rem;
            color: #94a3b8;
            line-height: 1.6;
        }

        .audio-controls {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.08);
            border-radius: 12px;
            padding: 28px;
            margin-bottom: 24px;
            display: none;
        }

        .audio-controls.active {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #e2e8f0;
        }

        .control-row {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .control-row button {
            flex: 1;
        }

        .waveform {
            width: 100%;
            height: 100px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid rgba(148, 163, 184, 0.08);
        }

        .waveform canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .input-field {
            width: 100%;
            padding: 12px 16px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 0.875rem;
            font-family: inherit;
            transition: all 0.2s;
            margin-bottom: 16px;
        }

        .input-field:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-field::placeholder {
            color: #64748b;
        }

        textarea.input-field {
            resize: vertical;
            min-height: 120px;
            line-height: 1.6;
        }

        select.input-field {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }

        select.input-field option {
            background: #1e293b;
            color: #e2e8f0;
        }

        .file-upload {
            position: relative;
            margin-bottom: 20px;
        }

        .file-upload input {
            display: none;
        }

        .file-upload-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 48px 32px;
            background: rgba(15, 23, 42, 0.6);
            border: 2px dashed rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload-label:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: #3b82f6;
        }

        .file-upload-label.has-file {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            border-style: solid;
        }

        .file-upload-icon {
            font-size: 2.5rem;
            color: #64748b;
        }

        .file-upload-text {
            font-size: 0.875rem;
            color: #94a3b8;
            font-weight: 500;
        }

        .file-upload-label.has-file .file-upload-text {
            color: #3b82f6;
        }

        .morse-display {
            background: rgba(15, 23, 42, 0.8);
            padding: 24px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1.25rem;
            letter-spacing: 0.15em;
            color: #3b82f6;
            margin: 20px 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(148, 163, 184, 0.08);
            text-align: center;
            word-break: break-all;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 20px;
            padding: 28px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.08);
        }

        .stat-box {
            text-align: center;
            padding: 16px 0;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #3b82f6;
            display: block;
            line-height: 1;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            font-weight: 600;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px 24px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            margin-bottom: 32px;
            border: 1px solid rgba(148, 163, 184, 0.08);
        }

        .volume-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #94a3b8;
            min-width: 80px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(148, 163, 184, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
            transition: transform 0.2s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }

        .volume-value {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #3b82f6;
            font-size: 0.875rem;
        }

        .log-container {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.08);
            border-radius: 12px;
            padding: 20px;
            max-height: 240px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.8125rem;
            line-height: 1.7;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.4);
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.6);
        }

        .log-entry {
            margin-bottom: 6px;
            display: flex;
            gap: 12px;
        }

        .log-time {
            color: #64748b;
            font-weight: 500;
            min-width: 70px;
        }

        .log-success { color: #10b981; }
        .log-error { color: #ef4444; }
        .log-warning { color: #f59e0b; }
        .log-info { color: #3b82f6; }

        @media (max-width: 1024px) {
            .container {
                padding: 32px;
            }

            .connection-grid {
                grid-template-columns: 1fr;
            }

            .source-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 640px) {
            .container {
                padding: 24px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .status-bar {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LASP - LoRa Audio Streaming Platform</h1>
            <p class="subtitle">Up to 8kHz Audio!</p>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-label">Connection Status</span>
                <span class="status-value inactive" id="connectionStatus">Disconnected</span>
            </div>
            <div class="status-item">
                <span class="status-label">Active Source</span>
                <span class="status-value inactive" id="sourceStatus">None</span>
            </div>
            <div class="status-item">
                <span class="status-label">Packets Transmitted</span>
                <span class="status-value" id="packetCount">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Transmission Rate</span>
                <span class="status-value" id="streamRate">0 pkt/s</span>
            </div>
        </div>

        <div class="section">
            <div class="connection-grid">
                <button id="connectBtn" class="btn-primary">
                    <span>Connect Device</span>
                </button>
                <button id="disconnectBtn" class="btn-danger" disabled>
                    <span>Disconnect</span>
                </button>
            </div>
        </div>

        <div class="section">
            <div class="section-header">Audio Input Sources</div>

            <div class="source-grid">
                <div class="source-card" id="micCard">
                    <div class="source-title">Microphone Input</div>
                    <div class="source-desc">Capture and stream live audio from your system microphone in real-time</div>
                </div>

                <div class="source-card" id="fileCard">
                    <div class="source-title">Audio File</div>
                    <div class="source-desc">Upload and transmit pre-recorded audio files in multiple formats</div>
                </div>

                <div class="source-card" id="toneCard">
                    <div class="source-title">Tone Generator</div>
                    <div class="source-desc">Generate precise frequency tones for testing and signal transmission</div>
                </div>

                <div class="source-card" id="morseCard">
                    <div class="source-title">Morse Code</div>
                    <div class="source-desc">Encode text messages as Morse code audio signals for transmission</div>
                </div>
            </div>
        </div>

        <div id="micControls" class="audio-controls">
            <div class="control-title">Microphone Configuration</div>
            <div class="waveform">
                <canvas id="micWaveform"></canvas>
            </div>
            <div class="control-row">
                <button id="startMic" class="btn-success">
                    <span>Start Recording</span>
                </button>
                <button id="stopMic" class="btn-danger">
                    <span>Stop Recording</span>
                </button>
            </div>
        </div>

        <div id="fileControls" class="audio-controls">
            <div class="control-title">Audio File Configuration</div>
            <div class="file-upload">
                <input type="file" id="fileInput" accept="audio/*">
                <label for="fileInput" class="file-upload-label" id="fileLabel">
                    <div class="file-upload-icon">⬆</div>
                    <div class="file-upload-text">Select audio file to upload</div>
                </label>
            </div>
            <div class="waveform">
                <canvas id="fileWaveform"></canvas>
            </div>
            <div style="margin: 20px 0;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.875rem; color: #94a3b8;">
                    <span id="currentTime">0:00</span>
                    <span id="totalDuration">0:00</span>
                </div>
                <input type="range" id="audioTimeline" class="volume-slider" min="0" max="100" value="0" step="0.1" disabled>
            </div>
            <div class="control-row">
                <button id="playFile" class="btn-success" disabled>
                    <span>Play</span>
                </button>
                <button id="pauseFile" class="btn-secondary" disabled>
                    <span>Pause</span>
                </button>
                <button id="stopFile" class="btn-danger" disabled>
                    <span>Stop</span>
                </button>
            </div>
        </div>

        <div id="toneControls" class="audio-controls">
            <div class="control-title">Tone Generator Configuration</div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 0.875rem;">
                    Frequency: <span id="freqValue" style="color: #3b82f6; font-weight: 600;">1000 Hz</span>
                </label>
                <input type="range" id="frequencySlider" class="volume-slider" min="100" max="3000" value="1000" step="50">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 0.875rem;">Waveform Type</label>
                <select id="waveformType" class="input-field">
                    <option value="sine">Sine Wave</option>
                    <option value="square">Square Wave</option>
                    <option value="sawtooth">Sawtooth Wave</option>
                    <option value="triangle">Triangle Wave</option>
                </select>
            </div>
            <div class="control-row">
                <button id="startTone" class="btn-success">
                    <span>Generate Tone</span>
                </button>
                <button id="stopTone" class="btn-danger">
                    <span>Stop Tone</span>
                </button>
            </div>
        </div>

        <div id="morseControls" class="audio-controls">
            <div class="control-title">Morse Code Configuration</div>
            <input type="text" id="morseInput" class="input-field" placeholder="Enter message to encode as Morse code...">
            <div class="morse-display" id="morseOutput">· · · – – – · · ·</div>
            <div class="control-row">
                <button id="playMorse" class="btn-success">
                    <span>Transmit Message</span>
                </button>
                <button id="stopMorse" class="btn-danger">
                    <span>Stop Transmission</span>
                </button>
            </div>
        </div>

        <div class="volume-control">
            <span class="volume-label">Output Level</span>
            <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="50">
            <span class="volume-value" id="volumeValue">50%</span>
        </div>

        <div class="section">
            <div class="section-header">Transmission Statistics</div>
            <div class="stats-grid">
                <div class="stat-box">
                    <span class="stat-value" id="statPackets">0</span>
                    <span class="stat-label">Total Packets</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="statRate">0.0</span>
                    <span class="stat-label">Packets/Second</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="statSamples">0</span>
                    <span class="stat-label">Samples Sent</span>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="statUptime">0:00</span>
                    <span class="stat-label">Stream Duration</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-header">System Activity Log</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

    <script>

        const TARGET_SAMPLE_RATE = 8000;
        const PACKET_SIZE = 480;
        const BAUD_RATE = 115200;

        const FRAME_START_1 = 0x61;
        const FRAME_START_2 = 0x6f;
        const FRAME_START_3 = 0x73;
        const FRAME_TYPE_AUDIO = 0xAD;

        let serialPort = null;
        let writer = null;
        let audioContext = null;
        let isStreaming = false;
        let currentSource = null;
        let packetCount = 0;
        let streamStartTime = null;

        let micStream = null;
        let analyser = null;
        let processor = null;
        let gainNode = null;
        let resampler = null;
        let sampleBuffer = [];

        let audioFileSource = null;
        let audioFileBuffer = null;
        let audioFileStartTime = 0;
        let audioFilePausedAt = 0;
        let isFilePlaying = false;

        let toneOscillator = null;
        let morseOscillator = null;

        let packetTimer = null;
        let lastPacketTime = 0;
        const PACKET_INTERVAL_MS = Math.floor((PACKET_SIZE / TARGET_SAMPLE_RATE) * 1000)-4; 

        const MORSE_CODE = {
            'A': '·–', 'B': '–···', 'C': '–·–·', 'D': '–··', 'E': '·', 'F': '··–·',
            'G': '––·', 'H': '····', 'I': '··', 'J': '·–––', 'K': '–·–', 'L': '·–··',
            'M': '––', 'N': '–·', 'O': '–––', 'P': '·––·', 'Q': '––·–', 'R': '·–·',
            'S': '···', 'T': '–', 'U': '··–', 'V': '···–', 'W': '·––', 'X': '–··–',
            'Y': '–·––', 'Z': '––··', '0': '–––––', '1': '·––––', '2': '··–––',
            '3': '···––', '4': '····–', '5': '·····', '6': '–····', '7': '––···',
            '8': '–––··', '9': '––––·', ' ': '/'
        };

        class ImprovedResampler {
            constructor(fromRate, toRate) {
                this.ratio = fromRate / toRate;
                this.inputBuffer = [];
                this.outputBuffer = [];
                this.inputIndex = 0;

                this.filterSize = 16;
                this.filter = this.createKaiserFilter(this.filterSize);
            }

            createKaiserFilter(size) {
                const filter = [];
                const beta = 5.0; 
                const i0Beta = this.besselI0(beta);

                for (let n = -size; n <= size; n++) {
                    const windowPos = n / size;
                    const window = this.besselI0(beta * Math.sqrt(1 - windowPos * windowPos)) / i0Beta;

                    if (n === 0) {
                        filter.push(window);
                    } else {
                        const x = Math.PI * n;
                        const sinc = Math.sin(x) / x;
                        filter.push(sinc * window);
                    }
                }

                const sum = filter.reduce((a, b) => a + b, 0);
                return filter.map(v => v / sum);
            }

            besselI0(x) {
                let sum = 1.0;
                let term = 1.0;
                const threshold = 1e-12;

                for (let k = 1; k < 50; k++) {
                    term *= (x * x) / (4 * k * k);
                    sum += term;
                    if (term < threshold * sum) break;
                }

                return sum;
            }

            process(inputSamples) {
                this.inputBuffer = this.inputBuffer.concat(Array.from(inputSamples));

                while (this.inputIndex + this.filterSize < this.inputBuffer.length) {
                    const exactIndex = this.inputIndex;
                    const baseIndex = Math.floor(exactIndex);
                    const fraction = exactIndex - baseIndex;

                    let sample = 0;
                    for (let i = -this.filterSize; i <= this.filterSize; i++) {
                        const sampleIndex = baseIndex + i;
                        if (sampleIndex >= 0 && sampleIndex < this.inputBuffer.length) {
                            const filterIndex = i + this.filterSize;
                            sample += this.inputBuffer[sampleIndex] * this.filter[filterIndex];
                        }
                    }

                    this.outputBuffer.push(sample);
                    this.inputIndex += this.ratio;
                }

                if (this.inputIndex > 2000) {
                    const removeCount = Math.floor(this.inputIndex);
                    this.inputBuffer.splice(0, removeCount);
                    this.inputIndex -= removeCount;
                }

                const output = this.outputBuffer.splice(0, this.outputBuffer.length);
                return output;
            }

            reset() {
                this.inputBuffer = [];
                this.outputBuffer = [];
                this.inputIndex = 0;
            }
        }

        function initAudioContext() {
            if (audioContext) return;

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const inputRate = audioContext.sampleRate;

            resampler = new ImprovedResampler(inputRate, TARGET_SAMPLE_RATE);

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.5;

            processor = audioContext.createScriptProcessor(2048, 1, 1);
            processor.onaudioprocess = (e) => {
                if (!isStreaming) {
                    const outputData = e.outputBuffer.getChannelData(0);
                    outputData.fill(0);
                    return;
                }

                const inputData = e.inputBuffer.getChannelData(0);
                const resampled = resampler.process(inputData);
                sampleBuffer = sampleBuffer.concat(resampled);

                const outputData = e.outputBuffer.getChannelData(0);
                outputData.set(inputData);
            };

            gainNode.connect(analyser);
            analyser.connect(processor);
            processor.connect(audioContext.destination);

            logMessage('Audio subsystem initialized with improved DSP', 'success');
        }

        function convertToPCM(floatSample) {

            const dither = (Math.random() - 0.5) / 256.0;
            const dithered = floatSample + dither;

            let clamped = Math.max(-1, Math.min(1, dithered));
            if (Math.abs(clamped) > 0.95) {
                clamped = Math.tanh(clamped * 2) * 0.95;
            }

            const scaled = (clamped * 127.5) + 127.5;
            return Math.max(0, Math.min(255, Math.round(scaled)));
        }

        function buildAudioPacket(audioData) {
            const totalSize = 4 + 1 + PACKET_SIZE + 1;
            const packet = new Uint8Array(totalSize);
            let checksum = 0;
            let idx = 0;

            packet[idx] = FRAME_START_1;
            checksum ^= packet[idx++];
            packet[idx] = FRAME_START_2;
            checksum ^= packet[idx++];
            packet[idx] = FRAME_START_3;
            checksum ^= packet[idx++];
            packet[idx] = FRAME_TYPE_AUDIO;
            checksum ^= packet[idx++];
            packet[idx] = 240;
            checksum ^= packet[idx++];

            for (let i = 0; i < PACKET_SIZE; i++) {
                packet[idx] = audioData[i];
                checksum ^= packet[idx++];
            }

            packet[idx] = checksum;
            return packet;
        }

        async function sendPacket(packet) {
            if (!writer) return;

            try {
                await writer.write(packet);
                packetCount++;
                updateStats();
            } catch (error) {
                logMessage(`Transmission error: ${error.message}`, 'error');
                stopStreaming();
            }
        }

        function startPacketSender() {
            lastPacketTime = performance.now();
            let packetsSent = 0;
            let startTime = lastPacketTime;
            let underrunCount = 0;

            packetTimer = setInterval(() => {
                if (!isStreaming) {
                    clearInterval(packetTimer);
                    return;
                }

                const now = performance.now();

                if (sampleBuffer.length >= PACKET_SIZE) {
                    const audioData = new Uint8Array(PACKET_SIZE);
                    const samples = sampleBuffer.splice(0, PACKET_SIZE);

                    for (let i = 0; i < PACKET_SIZE; i++) {
                        audioData[i] = convertToPCM(samples[i]);
                    }

                    const packet = buildAudioPacket(audioData);
                    sendPacket(packet);
                    packetsSent++;
                    lastPacketTime = now;
                    underrunCount = 0;
                } else {

                    underrunCount++;
                    if (underrunCount > 10) {
                        logMessage(`Audio starvation detected: only ${sampleBuffer.length} samples available`, 'warning');
                        underrunCount = 0;
                    }
                }

                if (sampleBuffer.length > PACKET_SIZE * 5) {
                    logMessage(`Buffer growing large: ${sampleBuffer.length} samples`, 'warning');
                }

            }, PACKET_INTERVAL_MS);

            logMessage(`Packet timer started: ${PACKET_INTERVAL_MS.toFixed(2)}ms interval`, 'info');
        }

        function startStreaming() {
            if (isStreaming) return;

            isStreaming = true;
            packetCount = 0;
            streamStartTime = Date.now();
            sampleBuffer = [];

            if (resampler) resampler.reset();
            startPacketSender();

            logMessage('Audio streaming initiated with precise timing', 'success');
        }

        function stopStreaming() {
            isStreaming = false;
            if (packetTimer) {
                clearInterval(packetTimer);
                packetTimer = null;
            }
            streamStartTime = null;
            logMessage('Audio streaming terminated', 'info');
        }

        function selectSource(source) {
            document.querySelectorAll('.source-card').forEach(card => {
                card.classList.remove('active');
            });
            document.querySelectorAll('.audio-controls').forEach(ctrl => {
                ctrl.classList.remove('active');
            });

            stopAllAudio();

            currentSource = source;
            document.getElementById(`${source}Card`).classList.add('active');
            document.getElementById(`${source}Controls`).classList.add('active');

            const sourceNames = {
                'mic': 'Microphone',
                'file': 'Audio File',
                'tone': 'Tone Generator',
                'morse': 'Morse Code'
            };

            const statusEl = document.getElementById('sourceStatus');
            statusEl.textContent = sourceNames[source] || 'None';
            statusEl.classList.remove('inactive');
            statusEl.classList.add('streaming');
        }

        function stopAllAudio() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            if (audioFileSource) {
                try { audioFileSource.stop(); } catch(e) {}
                audioFileSource = null;
            }
            if (toneOscillator) {
                try { toneOscillator.stop(); } catch(e) {}
                toneOscillator = null;
            }
            if (morseOscillator) {
                try { morseOscillator.stop(); } catch(e) {}
                morseOscillator = null;
            }

            isFilePlaying = false;
            stopStreaming();

            const statusEl = document.getElementById('sourceStatus');
            statusEl.classList.remove('streaming');
            statusEl.classList.add('inactive');
        }

        async function startMicrophone() {
            if (!audioContext) initAudioContext();

            try {
                micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: { ideal: 48000 }
                    }
                });

                const micSource = audioContext.createMediaStreamSource(micStream);
                micSource.connect(gainNode);

                startStreaming();
                animateWaveform('micWaveform');

                logMessage('Microphone input activated', 'success');
            } catch (error) {
                logMessage(`Microphone access error: ${error.message}`, 'error');
            }
        }

        function stopMicrophone() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            stopAllAudio();
        }

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                if (!audioContext) initAudioContext();

                const arrayBuffer = await file.arrayBuffer();
                audioFileBuffer = await audioContext.decodeAudioData(arrayBuffer);

                const fileLabel = document.getElementById('fileLabel');
                fileLabel.querySelector('.file-upload-text').textContent = file.name;
                fileLabel.classList.add('has-file');
                document.getElementById('playFile').disabled = false;
                document.getElementById('audioTimeline').disabled = false;

                const duration = audioFileBuffer.duration;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                document.getElementById('totalDuration').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('audioTimeline').max = duration;

                audioFilePausedAt = 0;

                logMessage(`Audio file loaded: ${file.name}`, 'success');
            } catch (error) {
                logMessage(`File processing error: ${error.message}`, 'error');
            }
        });

        document.getElementById('audioTimeline').addEventListener('input', (e) => {
            if (!audioFileBuffer || isFilePlaying) return;

            const time = parseFloat(e.target.value);
            audioFilePausedAt = time;

            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            document.getElementById('currentTime').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        });

        function updateFileTimeline() {
            if (!isFilePlaying || !audioFileBuffer) return;

            const elapsed = audioContext.currentTime - audioFileStartTime;
            const currentTime = Math.min(elapsed, audioFileBuffer.duration);

            document.getElementById('audioTimeline').value = currentTime;

            const minutes = Math.floor(currentTime / 60);
            const seconds = Math.floor(currentTime % 60);
            document.getElementById('currentTime').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            if (isFilePlaying) {
                requestAnimationFrame(updateFileTimeline);
            }
        }

        function playAudioFile() {
            if (!audioFileBuffer) return;

            audioFileSource = audioContext.createBufferSource();
            audioFileSource.buffer = audioFileBuffer;
            audioFileSource.connect(gainNode);

            audioFileSource.start(0, audioFilePausedAt);
            audioFileStartTime = audioContext.currentTime - audioFilePausedAt;
            isFilePlaying = true;

            startStreaming();
            animateWaveform('fileWaveform');

            document.getElementById('playFile').disabled = true;
            document.getElementById('pauseFile').disabled = false;
            document.getElementById('stopFile').disabled = false;

            updateFileTimeline();

            audioFileSource.onended = () => {
                if (isFilePlaying) {
                    stopAudioFile();
                    logMessage('Audio file playback completed', 'info');
                }
            };

            logMessage('Audio file playback started', 'success');
        }

        function pauseAudioFile() {
            if (!isFilePlaying) return;

            const elapsed = audioContext.currentTime - audioFileStartTime;
            audioFilePausedAt = Math.min(elapsed, audioFileBuffer.duration);

            if (audioFileSource) {
                try { audioFileSource.stop(); } catch(e) {}
                audioFileSource = null;
            }

            isFilePlaying = false;
            stopStreaming();

            document.getElementById('playFile').disabled = false;
            document.getElementById('pauseFile').disabled = true;

            logMessage('Audio file playback paused', 'info');
        }

        function stopAudioFile() {
            if (audioFileSource) {
                try { audioFileSource.stop(); } catch(e) {}
                audioFileSource = null;
            }

            isFilePlaying = false;
            audioFilePausedAt = 0;

            document.getElementById('audioTimeline').value = 0;
            document.getElementById('currentTime').textContent = '0:00';

            stopAllAudio();

            document.getElementById('playFile').disabled = false;
            document.getElementById('pauseFile').disabled = true;
            document.getElementById('stopFile').disabled = true;
        }

        document.getElementById('frequencySlider').addEventListener('input', (e) => {
            const freq = e.target.value;
            document.getElementById('freqValue').textContent = freq + ' Hz';
            if (toneOscillator) {
                toneOscillator.frequency.value = freq;
            }
        });

        function startToneGenerator() {
            if (!audioContext) initAudioContext();

            const frequency = parseInt(document.getElementById('frequencySlider').value);
            const waveform = document.getElementById('waveformType').value;

            toneOscillator = audioContext.createOscillator();
            toneOscillator.frequency.value = frequency;
            toneOscillator.type = waveform;
            toneOscillator.connect(gainNode);
            toneOscillator.start();

            startStreaming();
            logMessage(`Tone generator started: ${frequency}Hz ${waveform} wave`, 'success');
        }

        function stopToneGenerator() {
            if (toneOscillator) {
                try { toneOscillator.stop(); } catch(e) {}
                toneOscillator = null;
            }
            stopAllAudio();
        }

        document.getElementById('morseInput').addEventListener('input', (e) => {
            const text = e.target.value.toUpperCase();
            const morse = textToMorse(text);
            document.getElementById('morseOutput').textContent = morse || '· · · – – – · · ·';
        });

        function textToMorse(text) {
            return text.split('').map(char => MORSE_CODE[char] || '').join(' ');
        }

        async function playMorse() {
            const text = document.getElementById('morseInput').value.toUpperCase();
            if (!text) {
                logMessage('No message provided for Morse encoding', 'warning');
                return;
            }

            if (!audioContext) initAudioContext();

            const morse = textToMorse(text);
            const dotDuration = 100;

            startStreaming();
            logMessage('Morse code transmission initiated', 'success');

            for (let char of morse) {
                if (char === '·') {
                    await playTone(800, dotDuration);
                    await sleep(dotDuration);
                } else if (char === '–') {
                    await playTone(800, dotDuration * 3);
                    await sleep(dotDuration);
                } else if (char === ' ') {
                    await sleep(dotDuration * 3);
                } else if (char === '/') {
                    await sleep(dotDuration * 7);
                }
            }

            stopAllAudio();
            logMessage('Morse code transmission completed', 'info');
        }

        function playTone(frequency, duration) {
            return new Promise((resolve) => {
                morseOscillator = audioContext.createOscillator();
                morseOscillator.frequency.value = frequency;
                morseOscillator.type = 'sine';
                morseOscillator.connect(gainNode);
                morseOscillator.start();

                setTimeout(() => {
                    morseOscillator.stop();
                    resolve();
                }, duration);
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function stopMorse() {
            if (morseOscillator) {
                try { morseOscillator.stop(); } catch(e) {}
                morseOscillator = null;
            }
            stopAllAudio();
        }

        function animateWaveform(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            function draw() {
                if (!analyser || !isStreaming) return;

                requestAnimationFrame(draw);

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);

                ctx.fillStyle = 'rgba(15, 23, 42, 0.4)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.lineWidth = 2;
                ctx.strokeStyle = '#3b82f6';
                ctx.beginPath();

                const sliceWidth = (canvas.width / window.devicePixelRatio) / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * (canvas.height / window.devicePixelRatio) / 2;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                ctx.lineTo(canvas.width / window.devicePixelRatio, (canvas.height / window.devicePixelRatio) / 2);
                ctx.stroke();
            }

            draw();
        }

        function updateStats() {
            document.getElementById('statPackets').textContent = packetCount;
            document.getElementById('packetCount').textContent = packetCount;
            document.getElementById('statSamples').textContent = (packetCount * PACKET_SIZE).toLocaleString();

            if (streamStartTime) {
                const elapsed = Math.floor((Date.now() - streamStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('statUptime').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;

                const rate = elapsed > 0 ? (packetCount / elapsed).toFixed(1) : '0.0';
                document.getElementById('statRate').textContent = rate;
                document.getElementById('streamRate').textContent = `${rate} pkt/s`;
            }
        }

        function logMessage(message, type = 'info') {
            const log = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;

            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;

            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }

        document.getElementById('connectBtn').addEventListener('click', async () => {
            try {
                serialPort = await navigator.serial.requestPort();
                await serialPort.open({ baudRate: BAUD_RATE });
                writer = serialPort.writable.getWriter();

                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;

                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = 'Connected';
                statusEl.classList.add('connected');
                statusEl.classList.remove('inactive');

                logMessage(`Serial connection established at ${BAUD_RATE} baud`, 'success');
                initAudioContext();
            } catch (error) {
                logMessage(`Connection failed: ${error.message}`, 'error');
            }
        });

        document.getElementById('disconnectBtn').addEventListener('click', async () => {
            try {
                stopAllAudio();

                if (writer) {
                    await writer.releaseLock();
                    writer = null;
                }
                if (serialPort) {
                    await serialPort.close();
                    serialPort = null;
                }

                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;

                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = 'Disconnected';
                statusEl.classList.remove('connected');
                statusEl.classList.add('inactive');

                logMessage('Serial connection terminated', 'info');
            } catch (error) {
                logMessage(`Disconnection error: ${error.message}`, 'error');
            }
        });

        document.getElementById('micCard').addEventListener('click', () => selectSource('mic'));
        document.getElementById('fileCard').addEventListener('click', () => selectSource('file'));
        document.getElementById('toneCard').addEventListener('click', () => selectSource('tone'));
        document.getElementById('morseCard').addEventListener('click', () => selectSource('morse'));

        document.getElementById('startMic').addEventListener('click', startMicrophone);
        document.getElementById('stopMic').addEventListener('click', stopMicrophone);

        document.getElementById('playFile').addEventListener('click', playAudioFile);
        document.getElementById('pauseFile').addEventListener('click', pauseAudioFile);
        document.getElementById('stopFile').addEventListener('click', stopAudioFile);

        document.getElementById('startTone').addEventListener('click', startToneGenerator);
        document.getElementById('stopTone').addEventListener('click', stopToneGenerator);

        document.getElementById('playMorse').addEventListener('click', playMorse);
        document.getElementById('stopMorse').addEventListener('click', stopMorse);

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            if (gainNode) gainNode.gain.value = volume;
            document.getElementById('volumeValue').textContent = e.target.value + '%';
        });

        setInterval(() => {
            if (isStreaming) {
                updateStats();
            }
        }, 1000);

        if (!('serial' in navigator)) {
            logMessage('Web Serial API not supported in this browser', 'error');
            document.getElementById('connectBtn').disabled = true;
        } else {
            logMessage('System initialized with enhanced audio processing', 'success');
        }
    </script>
</body>
</html>